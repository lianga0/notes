# Go包导入的知识点

> From: https://github.com/iswbm/GolangCodingTime/blob/master/source/c03/c03_01.rst

Go语言是使用包来组织源代码的，包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。Go语言中为我们提供了很多内置包，如 fmt、os、io 等。

任何源代码文件必须属于某个包，同时源码文件的第一行有效代码必须是`package pacakgeName`语句，通过该语句声明自己所在的包。

## 1. 单行导入与多行导入

在 Go 语言中，一个包可包含多个 `.go` 文件（**这些文件必须得在同一级文件夹中，否则那就是俩不同的同名包了**），只要这些 `.go` 文件的头部都使用 `package` 关键字声明了同一个包。

- 包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。

- 一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。

导入包主要可分为两种方式：

单行导入

```
import "fmt"
import "sync"
```

多行导入

```
import(
    "fmt"
    "sync"
)
```

如你所见，Go 语言中 导入的包，必须得用双引号包含，在这里吐槽一下。


## 2. 使用别名

在一些场景下，我们可能需要对导入的包进行重新命名，比如

我们导入了两个具有同一包名的包时产生冲突，此时这里为其中一个包定义别名

```
import (
    "crypto/rand"
    mrand "math/rand" // 将名称替换为mrand避免冲突
)
```

我们导入了一个名字很长的包，为了避免后面都写这么长串的包名，可以这样定义别名

```
import hw "helloworldtestmodule"
```

防止导入的包名和本地的变量发生冲突，比如 path 这个很常用的变量名和导入的标准包冲突。

```
import pathpkg "path"
```

## 3. 使用点操作

如里在我们程序内部里频繁使用了一个工具包，比如 `fmt`，那每次使用它的打印函数打印时，都要 `包名.方法名`。

对于这种使用高频的包，可以在导入的时，就把它定义会 “自己人”（方法是使用一个 `.` ），自己人的话，不分彼此，它的方法，就是我们的方法。

从此，我们打印再也不用加 `fmt` 了。

```
import . "fmt"

func main() {
    Println("hello, world")
}
```

但这种用法，会有一定的隐患，就是导入的包里可能有函数，会和我们自己的函数发生冲突。


## 4. 包的初始化

每个包都允许有一个或多个 `init` 函数，当这个包被导入时，会执行该包的 `init` 函数，做一些初始化任务。

对于 `init` 函数的执行有两点需要注意

`init` 函数优先于 `main` 函数执行

在一个包引用链中，包的初始化是深度优先的。比如，有这样一个包引用关系：`main→A→B→C`，那么初始化顺序为

```
C.init→B.init→A.init→main
```

## 5. 包的匿名导入

当我们导入一个包时，如果这个包没有被使用到，在编译时，是会报错的。

但是有些情况下，我们导入一个包，只想执行包里的 `init` 函数，来运行一些初始化任务，此时怎么办呢？

可以使用匿名导入，用法如下，其中下划线为空白标识符，并不能被访问

```
// 注册一个PNG decoder
import _ "image/png"
```

由于导入时，会执行 `init` 函数，所以编译时，仍然会将这个包编译到可执行文件中。

## 6. 导入的是路径还是包？

当我们使用 import 导入 `testmodule/foo` 时，初学者，经常会问，这个 foo 到底是一个包呢，还是只是包所在目录名？

```
import "testmodule/foo"
```

- 导入时，是按照目录导入。导入目录后，可以使用这个目录下的所有包。

- 出于习惯，包名和目录名通常会设置成一样，所以会让你有一种你导入的是包的错觉（可以理解为导入语句的作用是让Go加载指定目录中的包名，实际上目录是目录，包名是包名）。

- 当包名与目录名不一致时，如果导入包时不显示的使用别名，那么代码将比较难以阅读（因为导入目录名并不是目录下包的名字，代码中必须使用正确的包名，用户需要知道目录名和包名的关系，增加额外的记忆负担）。

- 一个目录下只能一个包一般是正确的，但有个特殊情况，如果源码文件中包含了测试，测试的包名可以与主包名不同（主包名+`_test`）。

- 一个目录下的包名仅与`package packagename`命令定义的名字相关，而与包所在的文件名无关


## 7. 相对导入和绝对导入

据我了解在 `Go 1.1`0 之前，好像是不支持相对导入的，在 `Go 1.10` 之后才可以。

绝对导入：从 `$GOPATH/src` 或 `$GOROOT` 或者 `$GOPATH/pkg/mod` 目录下搜索包并导入

相对导入：从当前目录中搜索包并开始导入。就像下面这样

```
import (
    "./module1"
    "../module2"
    "../../module3"
    "../module4/module5"
)
```

** Go Modules 不支持相对导入，在你开启 `GO111MODULE` 后，无法使用相对导入。**

最后，不得不说的是：使用相对导入的方式，项目可读性会大打折扣，不利用开发者理清整个引用关系。

所以一般更推荐使用绝对引用的方式。使用绝对引用的话，又要谈及优先级了

## 8. 包导入路径优先级

Go不同的包依赖管理方案，不同的管理模式，存放包的路径可能都不一样，有的可以将包放在 GOPATH 下，有的可以将包放在 vendor 下，还有些包是内置包放在 GOROOT 下。

那么问题就来了，如果在这三个不同的路径下，有一个相同包名但是版本不同的包，我们导入的时候，是选择哪个进行导入呢？

这就需要我们搞懂，在 Golang 中包搜索路径优先级是怎样的？

这时候就需要区分，是使用哪种模式进行包的管理的。

### 如果使用 govendor

当我们导入一个包时，它会：

- 先从项目根目录的 `vendor` 目录中查找
- 然后从 `$GOROOT/src` 目录下查找
- 然后从 `$GOPATH/src` 目录下查找
- 都找不到的话，就报错。

### 如果使用 go modules

你导入的包如果有域名，都会先在 `$GOPATH/pkg/mod` 下查找，找不到就连网去该网站上寻找，找不到或者找到的不是一个包，则报错。

而如果你导入的包没有域名（比如 “fmt”这种），就只会到 `$GOROOT` 里查找。

还有一点很重要，当你的项目下有 vendor 目录时，不管你的包有没有域名，都只会在 `vendor` 目录中查找。

通常 `vendor` 目录是通过 `go mod vendor` 命令生成的，这个命令会将项目依赖全部打包到你的项目目录下的 `verdor` 文件夹中。


## 9. 使用 replace 替换无法直接获取的 package

由于某些已知的原因，并不是所有的 package 都能成功下载，比如：golang.org 下的包。

modules 可以通过在 go.mod 文件中使用 replace 指令替换成 github 上对应的库，比如：

```
replace (
    golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a => github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a
)
```

或者

```
replace golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a => github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a
```

Reference：[Go语言包的基本概念](http://c.biancheng.net/view/5394.html)

[Go语言go mod包依赖管理工具使用详解](http://c.biancheng.net/view/5712.html)
