# yara规则语法

## 访问指定位置的值`uint32(<offset or virtual address>)`

在 YARA 规则中，使用 `uint32` 和虚拟地址的组合可以帮助分析特定内存位置的数据。下面是一个详细的示例，说明如何在 YARA 规则中使用 `uint32` 和虚拟地址。

### 示例场景

假设我们有一个恶意软件样本，其在内存中某个特定虚拟地址存储了一个关键的标志位或函数指针。我们希望使用 YARA 检测这一特征。

```
rule ExampleRule
{
    strings:
        $h01 = { 6A 00 68 ?? ?? ?? ?? 8B ?? ?? ?? ?? ?? 83 C4 0C }
    condition:
        uint32(@h01 + 0x0100) == 0x12345678
}
```

### 解析示例

字符串块 (`strings`):
`$h01` 是一个字节序列的模式，表示我们正在寻找与该模式匹配的部分。在这里，`{ 6A 00 68 ?? ?? ?? ?? 8B ?? ?? ?? ?? ?? 83 C4 0C }` 是我们要查找的字节序列，可以是恶意软件的某个特征。

条件块 (`condition`):
`uint32(@h01 + 0x0100)` 表示从匹配到的 `$h01` 地址开始，向后偏移 256 字节（0x0100），并将该位置的4个字节数据解释为一个无符号32位整数。
`== 0x12345678` 是我们要检查的条件，表示希望偏移后读取到的 4 个字节的值等于 `0x12345678`。

### 实际分析
内存映射：当 YARA 扫描目标文件或内存时，如果找到了 `$h01` 的匹配，YARA 会计算出 `$h01` 开始位置的内存地址，然后加上 256 字节的偏移量。
数据读取：YARA 将从计算出的地址读取 4 个字节，并将其作为无符号32位整数进行比较。如果这个值等于 `0x12345678`，则规则匹配成功。

更详细的规则示例如下：

```
rule test_a
{
    meta:
        description = "This is just an example,进程pid扫描时，可以直接指定进程虚拟地址的偏移"
        threat_level = 3
        in_the_wild = true
    strings:
        $a = {40 C1 0B FA FF FF FF FF 08 00 00 00 01 00 83 00 47 38 C6 9F D8 5F DB 01 00 C0 5D 84 6E 7A DC 01 E7}
    condition:
        uint8(@a+0x01) == 0xC1 and uint16(@a) == 0xc140 and uint32(@a) == 0xfa0bc140 and uint32(@a+0x01) == 0xfffa0bc1 and uint8(@a+0x20)==0xE7 and uint8(@a+0x21)==0x00 and uint8(0x7FFE0010)==0xa0
}
```

其中，`uint8(@a+0x01)`表示字符串`$a`匹配的内存起始地址加1的位置，也就是`$a`字符串的第二个字节，其值为`0xC1`，所以条件`uint8(@a+0x01) == 0xC1`在字符串`$a`匹配的情况下永远为真。
条件`uint16(@a) == 0xc140`表示比较符串`$a`匹配的内存起始地址两个字节内容，由于Intel和AMD等常见架构，默认是小端，所以前两个字节写为unit16的值为`0xc140`。
