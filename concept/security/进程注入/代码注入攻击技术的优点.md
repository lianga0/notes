# 代码注入攻击技术的优点

恶意软件可以在系统上删除新文件、创建新的注册表项及其键值、启动网络连接、创建进程以及插入新内核模块等。在代码注入技术中，一个进程可以将自身正在运行的一部分或全部代码，插入到另一个目标进程中，并让目标进程执行注入的代码。

代码注入技术成为恶意软件的主要手段之一有以下几个优点的原因：

## 1. 隐藏自身

恶意软件通过将其恶意代码注入到系统上运行的其他合法进程（如 explorer、svchost 和 winlogon 等）并退出自身恶意进程，通过被注入的目标进程来执行恶意代码。如此恶意软件既可以避免自身进程被任务管理器的进程列表所扫描，同时还可以绕过反恶意软件的扫描。

## 2. 策略绕过

当恶意软件行为包括网络连接时，恶意软件可以将网络连接模块代码注入到具有联网权限的本地合法进程内，通过合法进程代替恶意软件进行网络连接，从而绕过操作系统的限制和防火墙的安全策略。

被注入的目标进程可以是系统上正在运行的合法进程，也可以由恶意软件自建。对于用户空间，每个进程有自己的私有虚拟内存空间，其分为用户模式和内核模式。若恶意软件将代码注入到目标进程的用户模式部分，则只有该目标进程受到恶意软件的影响。修改内核会影响系统上的所有进程。但是，通过添加内核模块或修改现有内核模块来注入内核较难实现，并且内核受到高度保护，不容易被修改，这使得内核模块不受恶意软件的青睐。

通过逆向分析近年来常见的恶意软件，得出经常使用到的代码注入攻击技术包括但不局限于：进程挂钩、线程注入、DLL注入、Atom bombing 以及QueueUserAPC 等。


# Windows 代码注入攻击检测研究现状

黑客可以利用代码注入技术和 0 day 漏洞相结合，对目标主机进行攻击。Windows 系统为了避免这种情况，实现了指令随机化（Instruction randomization，ISR）和地址空间布局随机化（Address space layout randomization，ASLR）两种系统保护机制。

代码注入攻击的根源是计算机不能明确区分数据和代码，因此 Windows 系统又增加了数据执行保护（Data execution protection，DEP）安全机制，DEP 将数据所在的内存页标识为不可执行，当程序执行 shellcode 是就会尝试在数据页上执行指令从而 CPU 抛出异常。但是当 DEP 原理被刨析清楚后，攻击者可以使用 ROP 技术以绕过 DEP 执行恶意代码。

2015 年 Glendowne 利用 VirusShare 获得大量包含恶意DLL行为的 Windows 7 x86 内存转储文件，结合机器学习提取 DLL 注入攻击的行为特点。但该方法不适用于其他代码注入攻击手段。

近年来在内存取证领域，代码注入攻击检测研究方法在完整性验证方面，已经解决了可执行代码和 IAT/EAT 的完整性问题。通过比较目标代码中的内容和原始版本中的可用内容来检查完整性。White 提出了一种基于虚拟地址描述符（Virtual address descriptor，VAD）自动比较内存中加载的 PE 文件与磁盘上的实际文件的方法来检测恶意软件所做的修改。该方法在恶意软件影响代码或ITA/EAT 的情况下非常有效，但只能处理静态部分，大量的内存所包含的动态内容会在执行过程中会发生更改，White 所提出的方法不能针对动态内容的取证分析。

## 代码注入类型及其特点研究

通过对代码注入恶意样本逆向分析发现，代码注入攻击可以根据注入的目标进程类型不同分为：目标进程为系统已存类型的代码注入攻击和目标进程为病毒自建类型的代码注入攻击。

在内存取证角度，对于目标进程为病毒自建的代码注入攻击，由于不确定目标进程在何时被恶意软件创建或退出，不确定在执行完恶意代码后被注入的页面是否由于页面换出而不在物理内存中。当页面不在物理内存中时，静态内存分析失效，从而引入 Rekall 动态取证；对于目标进程为系统已存类型的代码注入攻击，只需考虑运行时间以及取证效率，从而使用 Volatility 框架静态取证。通过对代码注入技术的分析发现，该技术包含两处共同点，即在目标进程中分配内存空间并提供执行注入代码所需的正确保护，以及获取程序执行流程以执行所注入的恶意代码。

## 代码注入攻击检测研究

现有的代码注入攻击检测研究着重于32位操作系统，对于目标进程为系统已存类型的代码注入攻击，提出了通过交叉验证进程堆栈和 VAD 信息定位注入代码方法，将基于遍历栈帧得到的函数返回地址、模块名等信息结合进程 VAD 结构来检测函数返回地址、匹配文件名以定位 Windows 32/64 位操作系统中注入的代码。

对于目标进程为病毒自建的代码注入攻击，通过遍历分页结构以检测页面的实际可执行状态来检测目标进程为病毒自建类的 Windows 代码注入，由于尚未分配的内存页和映射映像文件（加载的可执行文件和 DLL）的未修改页不可能包含注入代码，将上述两种情况排除在检测范围外。


# 虚拟内存

硬件内存管理单元（MMU）使用内存中的一组查找表将虚拟地址转换为物理地址，其中查找表的根是通过一个特殊的 CPU 寄存器（在 x86 中称为 CR3）访问。每个进程的物理内存和虚拟地址空间被组织成页式的内存单元。
每个进程拥有自己的 CR3 值从而实现不同进程在地址转换时相对独立，该值指向分页结构中最高级的页表（Page-Map-Level-4，PML4）。为了计算实际的物理内存地址，MMU 需要遍历页表结构，直至最后的页表条目（PTE）。将物理页面偏移与页面帧的地址相加，得到实际物理地址。为了加速，今天的处理器在特殊的硬件缓存中存储已经翻译的虚拟到物理地址映射，称为转换后备缓冲器（TLB）。

## 页面状态

用户进程虚拟地址空间中的页面可能包含以下几种状态：

1. 空闲状态 进程无法访问该状态下的页面，此时页面可以被提交、保留，尝试读取或写入空闲页面会导致访问冲突异常。进程可以使用 VirtualFree()或VirtualFreeEx()函数来释放其地址空间的保留或提交页面，将其返回到空闲状态。

2. 保留状态 该状态下页面已被保留以供将来使用，其地址范围不能被其他分配函数使用，保留页面不可访问，并且没有与之关联的物理存储。进程可以使用 VirtualAlloc()或 VirtualAllocEx()函数来保留其地址空间内的页面，然后提交被保留的页面。相应地，进程可以使用 VirtualFree()或 VirtualFreeEx()来释放提交的页面并将其返回到保留状态。

3. 提交状态 只有在首次尝试读取或写入该状态下的页面时，系统才会初始化每个提交的页面并将其加载到物理内存中。当进程终止时，系统会释放已提交页面的存储空间。进程可以使用 VirtualAlloc()、VirtualAllocEx()或VirtualAllocExNuma()来分配已提交的页面。若提交页面在被分配后从未被访问，则其在首次被访问时会被创建为零初始化的页面。

## 进程堆栈差异

在 Windows x86 中，除了 fastcall 之外的所有调用约定都将所有参数存放在堆栈上；在 x64 架构中 fastcall 成为函数的默认调用约定。在经过 x86 和 x64 堆栈的差异对比分析后，总结如下：

1. 寄存器的更改 在 x64 中添加了 8 个新寄存器 r8-r15；Rbp 不再用作栈帧指针所使用，而是一个通用寄存器；

2. 参数传递 fastcall 调用约定下的函数参数传递不同于 x86 平台，调用约定将前 4 个参数存放在寄存器中（RCX、RDX、R8 和 R9），其余参数放在堆栈中。

3. 函数内联 x64 编译器执行函数的内联扩展，如果满足某些条件，其将用被调用者的主体替换对函数的调用。尽管内联并不是 x64 所独有的，但 x64 编译器对内联函数使用频繁。源文件级别的内联由编译器的 `/Ob` 标志控制，并且可以通过`_declspec(noinline)`在每个函数的基础上禁用内联。

4. 尾调用消除 在 x64 中，可以优化一个函数的最后一次调用，将其替换为跳转到被调用函数所执行。

5. 访问局部变量 在 x86 环境中，栈帧指针（EBP）寄存器最重要的功能是提供对基于堆栈的参数和局部变量的访问。如前所述，在 x64 上 Rbp 寄存器不指向当前函数的栈帧。因此，在 x64 上，Rsp 寄存器同时用作栈指针（stack pointer）和栈帧指针。所以 x64 中的所有栈引用都是基于 Rsp 所 执行的。

6. 归位空间 尽管前四个参数是通过寄存器传递的，但在栈中仍有为这四个参数分配的空间。这被称为参数归位空间，如果函数是通过地址访问参数，而不是通过值访问参数；或者函数在编译时带有/homeparams 标志，那么这个栈空间就被用来存储参数值。当归位空间不用于存储参数值时，编译器会用其来保存非易失性寄存器。

7. 参数归位 如归位空间所述，所有 x64 非叶函数都在其栈帧中分配了参数归位区域。按照 x64 调用约定，调用者将始终使用寄存器将前 4 个参数传递给被调用者（在汇编中体现为 `sub rsp,20h`）。当使用编译器的/homeparams 标志启用参数归位时，只有被调用者的代码会受到影响。

8. GS 保护 GS 是 Windows 操作系统为防止栈溢出而设计的保护机制。x86在发生函数调用时，会向栈帧内压入一个随机数（Security Cookie），并且此随机数还将保存在.data 的内存区域中，在栈帧中该随机数位于栈帧指针之前。从而当栈中发生溢出时，该随机数将被首先覆盖，之后才是 Ebp 和返回地址，该随机数还将与 Ebp 内容进行异或，增强了随机性。在函数返回之前，系统将执行一个安全验证操作（Security cheek），将栈中的操作数与存放在.data 中的操作数进行比较，若不相同，说明栈帧中的随机数被破坏，既栈中发生了溢出。

From: 基于内存取证技术的Windows代码注入攻击检测研究,2023,韩旭
