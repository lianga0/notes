# 内核态是指一个特殊的进程，还是指进程的一种特殊状态？

> From: https://www.zhihu.com/question/40147261

当我们说“从用户态切换到内核态”时(例如在进行系统调用read或fork时)，是指当前的进程从一种状态进入了另一种状态(并没有进程的切换)？还是指当前的进程被挂起了，另一种特殊的内核进程被调度(发生了进程切换)？

也就是说“态”的切换和“进程”切换有没有联系？

> 
> 问题2：请问，内核空间其实是完全共享的吗？大家看到的数据都是相同的，如果修改数据，会影响到所有进程？也就是说，其实内核空间其实只占用一份物理内存？另外，既然都是相同的，所谓“内核栈是各用各的”是啥意思？
> 
> 问题2回答：是完全共享的。内核的代码是有权限修改所有进程的，但是内核代码的书写者写的代码不会这样做，会很小心。也即内核是能为而不为。只占用一份物理内存。只不过这一块是进程A的内核栈，那一块是进程B的内核栈，作为内核代码，我都能动，但是我不随便动。

## 知乎用户G0K17q回答：

在大部分情况下，我们认为内核态是一种CPU的特权态，这个特权态下，CPU可以执行这个特权态才允许执行的指令，访问这个特权态才运行访问的资源。这和当前的进程无关。OS通过控制不同的特权态来控制资源分配。一般有两种方法切换特权态，一种是特殊的指令，比如x86的软中断指令，或者大部分RISC系统的系统调用指令（比如SC），第二种是执行异常或者外部中断。发生切换后，现在到底是哪个进程，其实是无所谓的。现在说说现代LINUX如何定义线程和进程。我倾向于这样解释线程和进程:线程本质就是堆栈，当一段程序在执行，能代表它的是他的过去和现在。"过去"在堆栈中，"现在"则是CPU的所有寄存器，如果我们要挂起一个线程，我们把寄存器也保存到堆栈中，我们就具有它的所有状态，可以随时恢复它。这是线程。当我们切换线程的时候，同时切换它的地址空间（通过修改MMU即可），则我们认为发生了进程切换。所以进程的本质是地址空间，我们可以认为地址空间决定了进程是否发生切换。回到最初的问题，当CPU的特权级刚刚发生切换的时候，显然和进程，线程的切换是无关的，但之后调度器是否切换线程和进程，则和具体的情形相关了。


## 锦鲤回答：

如楼上所说，cpu一般有多个权限层级，linux使用了最高和最低两个层级。并且分别在这两个层级中运行内核和用户程序。

也就是说，内核运行在最高权限下，而普通的进程则运行在最低权限下。当普通进程需要访问其没有权限的资源时就会有两种选择，

1.调用内核提供的接口进入内核态，使用相关函数获取资源

2.等待内核以某种方式提供所需资源，这种方式最终也要回归到1上。

在1中，实质是用户态程序调用了内核所提供的函数而已，并不会造成进程切换。

你可以将内核态与用户态理解成一种操作系统对用户程序在权限与资源上的限制机制，而这种机制是基于cpu提供的不同权限的运行状态来实现。

知乎上看到过一句话：OS不是运行着的代码，而是一堆躺在内存里等着被调用的代码。

放在这里就是“我用你提供的锤子砸了个钉子”，而不是“你去帮我砸个钉子”。

## Tim Chen​回答：

Windows里面，对于普通进程来说，如果通过系统调用进入内核代码运行，当前的栈指针和EIP之类的context是发生变化的，即会进入内核内存空间，但是当前的进程context并没有变化，进程的用户内存空间还是原来这个进程的，而内核内存空间由于是所有进程所共享的，所以并没有什么区别。

不过Windows里面确实有一个叫SYSTEM的特殊进程，这个独立的进程里面只运行内核态的线程，并且没有用户态内存空间。这和通过系统调用进入内核的方式不太一样，因为这些线程打一开始就一直在内核态运行。

还有一些情况下，比如处理中断的时候，并不会有明显的进程上下文，因为在那个高调度级别用户态进程上下文是没有什么用处的，并且那个级别基本也不可能去访问用户内存空间，因为没法正常处理page fault。

另外，内核态的代码在某些时刻是可以通过内核提供的API来attach到指定的进程的，当然会有一定限制。


## VizXu​回答：

在我对计算机系统还不甚了解的时候，每当听到诸如进程线程内核态用户态的时候，我也是有楼主这种疑问的。到底内核态是一个进程呢，还是说是进程的某种特殊状态？

其实答案是内核态既不是一个特殊的进程也不是某个进程的特殊状态。

我们从计算机远古时代开始，那时候的操作系统很简陋，没有进程切换，也不支持抢占，甚至最起先连中断都没有，这个时候系统是从头跑到尾，直至结束。那么可不可以说这个系统就是一个进程呢？其实这个地方是有一点认识上的偏差的，某种意义上说这时候这个系统所干的事情和现在的一个进程所干的事情也差不多，所以把这个最最简单的一口气跑到底的操作系统看成一个进程貌似也没错。

后来计算机发展了，不管是硬件还是软件，硬件上中断，多核，SMP，AMP，NUMA等出现了；软件上分时操作系统，进程，线程，协程，并发，进程迁移，进程切换，抢占，中断上下文等概念出现了。其中进程概念的出现是先于线程和协程的，事实上是现实需求逼迫分时操作系统的出现，而进程也一起出现了，包括和它一起出现的进程切换，并发，抢占，中断上下文等。为什么是现实需求逼迫？因为通用的操作系统不能像上面那个系统那么简单，一次只处理一个任务，高级的操作系统必须要同时处理多个任务，这一个个任务就是由一个个进程来承载的。

从这个时候开始进程来承载各种任务，操作系统则作为大管家一样管理着这些进程。但是到这里还是有一些问题要解决，那就是操作系统作为大管家直接接触硬件，一个普通的进程如果可以直接操作硬件那么这个系统的安全性没办法保障，然后这个现实的对安全的需求又逼迫操作系统需要分离出至少两种状态，一种状态是运行的代码可以操作硬件，一种状态是运行的代码不能直接操作硬件只能切换到第一种状态然后执行一些操作再切换回来。这就是我们要说的内核态和用户态的分野。

到这里，我们还有一个问题要解决，内核态和用户态的分野仅仅靠软件可以实现吗？我个人的理解是不行的，必须借助硬件。好在不管是intel还是arm的通用处理器都会提供指令代码的特权级。以intel为例，它提供了ring0-3的特权级，其中内核态工作在ring0用户态工作在ring3，大家发现了ring1-2我们的操作系统没有去使用，为啥呢，因为是不必需的。内核态的代码可以直接操作硬件，比方切换cr3的基地址寄存器，比方触发IO控制器等等。用户态代码没有这种权限，如果强制在用户态代码中埋一些特权指令那么执行的时候会报错，这是硬件提供的保障，用户态代码如果确实需要执行硬件操作，只能切换到内核态来进行，如何切换，ioctl，系统调用都可以，本质上是触发int0x80的中断让代码陷入内核态。

好了，到现在我们知道了内核态用户态的工作方式，我们再来看看进程本身。刚才我们说了，用户态代码要想操作硬件需要切换到内核态，这里用户态代码是不是一定属于某个进程？我的理解是没错，用户态代码一定属于某个进程，为什么？因为用户态代码肯定是fork出来的。那内核态代码一定属于某个进程吗？答案是不一定，可能属于某个进程，也可能不是，可能属于某段进程切换上下文，也可能属于某个中断上下文，这些代码都不是进程本身，是属于操作系统层面的概念。

我们来看，一个CPU执行代码，只可能是以下的某种形式：

1、CPU代表进程工作在用户态，也就是这个进程正在执行代码，且这些代码不涉及特权指令操作，只是一些通常的操作，比方算个加法啥的。

2、CPU代表进程工作在内核态，也就是说这个代码还是属于某个进程，但已经工作在内核态了，原因是啥？原因就是这个进程调用了ioctl或者系统调用陷入到内核态了。

3、CPU代表硬件工作在内核态，这个时候代码的执行已经不属于任何进程了，这些代码是操作系统层面的，可以说进程切换上下文，也可以是中断上下文。

到这里这个问题差不多解释清楚了，内核态不是某个进程，是代码执行的一种状态 ，这些代码可以是进程代码也可以是操作系统本身的代码。进程可以工作在用户态也可以工作在内核态，不管是用户态内核态代码的执行本质上没有差别，唯一的差别只在于是否是特权级。


## 望山回答

通过系统调用进入内核态的时候，当前进程还是确定的，比如还是可以访问当前进程的用户态内存区域、使用当前进程打开的文件。内核态有更高的权限，可以通过某些方式去访问非当前进程所有的资源，比如属于其他进程的、或者操作系统自己管理而不属于任何用户进程的资源。

通过硬件中断进入内核态的时候，不管当前处于哪个进程和线程（无论当前在用户态还是内核态），ISR都要进行必要的响应，它是为整个系统所有进程和线程服务的。虽然当有特定需求的时候，ISR也可以取得被中断的进程和线程的信息，但仅仅是为了某些中断响应工作的需要，而不是被中断的进程和线程的需要，ISR对于被中断的进程和线程基本上是透明的，所以概念上通常不认为ISR是属于被中断的进程的。

## 爱吃香蕉的乡巴猪的回答

在此，我以Linux为例来回答你的问题。

Linux是一个单体OS，在单体设计中没有kernel。换句话说，kernel事实上是进程的一部分。

内核代码常常执行在如下两个上下文中(contexts)

- Process
- Interrupt

针对你的问题，主要讲解一下Process context。

OS在某种程度上可以看作一个server， 一个process可以通过系统调用(system call)向OS请求相应的服务。当这个发生的时候，该process在内核态执行系统调用的内核代码。

故可以定义 Process Context为：内核代码现在在调用系统调用的进程的上下文中运行。

每个Process Context具有如下的属性：

- 总是有process/thread通过系统调用触发
- 自上而下
- 进程同步执行内核代码

有了上述知识，来看一个最简单的例子

```
#include <stdio.h>
   main()
   {
printf(“hello, world\n”); }
```

上述的过程可描述如下：

- 进程P发出printf(3) library call
- printf接口发起write(2)系统调用
- 进程P现在从用户态切换到内核态
- 进程P运行底层的内核代码，底层的设备驱动代码，并写hello world到Monitor
- 进程P然后切换回用户态

因此，粗略上讲 内核态可以看作进程的一种特殊状态！

## 执行该操作的回答

内核态首先是CPU的一种执行状态，在这个状态下CPU可以执行某些低特权级下被禁止直行的特权指令。

那么我们考虑一下，如果一个线程进入了内核态，而此时发生了抢占或内核代码自愿让出执行权，内核会做什么？

第一种情况，抢占被禁止或推迟（比如关闭中断），那么这种情况也就无所谓是“线程处于内核态”还是“内核态是一个特殊的线程”，因为此时的内核是在无视调度的情况下运行的。中断处理程序基本都是这样的状态。

第二种情况，抢占被允许，或者让出执行权，那么这个处于内核态的现场会被保存到与那个线程相关的记录中，并且在恢复该线程执行时会回到这个处于内核态的现场，在这种情况下，显然“内核态是线程的一种特殊状态”是合适的。

两者结合起来，我们当然可以说内核态是线程的一种特殊状态。

不过的确也有一些线程，它们没有用户态代码，只有内核态代码，它们自始至终都在内核态运行。


## Leon的回答

在Linux系统中，每个用户进程都有二个栈，一个是用户栈和一个用于此进程的专用内核栈。

进程的用户栈驻留在用户地址空间 （比如，32位 X86架构下的前3GB空间）。
进程的内核栈驻留在进程的内核地址空间（3GB-4GB）中。
当用户进程需要执行某些特权指令（比如，系统调用）时，它陷入内核态，内核代表用户进程继续执行它。这个执行在进程的内核栈上进行。

回到你的问题：

假定不同进程陷入内核态执行相同系统调用（比如，打开文件）时，它的代码还是那些指令，但系统调用的执行上下文并不相同，分别在各自进程对应的内核栈上。 （记住：在Linux系统中，每个用户进程都有二个栈，一个是用户栈和一个用于此进程的专用内核栈）


TSS寄存器用来存储进程内核栈的段选择器。

在系统调用时，用户进程将所有调用方使用的寄存器压入进程的用户栈，并执行int系统调用指令。之后硬件会负责从TSS中找到进程的内核栈地址，并将这些值加载到SS/SP/IP/CS中。因此，系统调用执行时，需要堆栈访问的操作都使用这个进程对应的内核栈而不是进程的用户栈。系统调用执行结束后，硬件再次将保存在内核栈中的寄存器值弹出，并恢复到进程的用户栈中。

在Linux系统中，每个用户进程都有二个栈，一个是用户栈和一个用于此进程的专用内核栈。你可以尝试从这个角度来理解你的问题。

注意：此处的进程空间对应的都是虚拟内存，进程专用内核栈仅仅为逻辑意义上的专用。

## 云天明的回答

关于进程

进程对cpu几乎是透明的，在进程切换时，cpu的比较大的变动是切换CR3(指向页表的寄存器)和TLB(用于缓存页表)

对于操作系统来说进程实际上是一个进程表的一项，当进程切换发生时，进程调度程序保存当前程序的运行现场，然后载入要运行的程序的现场。

1。当一个进程通过系统调用进入内核态

进程正常情况下是不被允许从RPL较大的代码(用户态)跳转到RPL较小的代码(特权更高的用户态或内核态)的，从用户态进入内核态只有三种办法：门(调用门/陷阱门)，syscall，sysenter，。系统调用一般使用调用门，而syscall和sysenter的过程和调用门是相似的。

这就决定了，通过系统调用从用户态进入内核态，必然有CR3切换，必然有栈切换，必然有上下文保存。

所以说，对于进程本身来说，内核态已经不属于当前进程了。

但是如果不触发进程调度，进程调度程序所认为的“当前进程”依然是进入内核态之前的进程。

但是系统调用处理程序可以随时转到进程调度程序，从而更改“当前进程”，系统调用处理程序甚至可以屏蔽中断以避免转交控制，甚至可以关闭分页和分段进入实模式。


2.通过中断进入内核态

进程不被允许触发这一类中断，当硬件状态改变或发生其他的事情时，中断控制器(或者别的东西)会向cpu发出中断请求，此时cpu会通过陷阱门执行特定的内核代码(中断处理程序)，此时发生cr3切换和栈切换，所以已经相当于进程切换了。

中断处理程序会保存现场，然后干任何想干的事情

当然，有些中断是不会交给中断处理程序的，甚至这样的中断是对操作系统透明的——比如SM中断，啊实际上是系统管理中断，这就是连微软感受到被支配的恐惧的中断——cpu接受到系统管理中断时，会立刻转到SMM(系统管理模式)，并在一个神秘的地址空间执行bios代码。这个地址空间是os看不到的。

我个人觉得，进程对于操作系统来说只是数据结构，对于内核代码，比如系统调用处理程序，中断处理程序和进程调度程序，甚至“进程”这个词都是无意义的，它们不属于任何进程。这些跳出三界外，不在五行中的内核态代码，根本就不在乎“进程”。